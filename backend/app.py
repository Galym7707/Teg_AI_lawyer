# -*- coding: utf-8 -*-
import os
import json
import time
import logging
from typing import Dict, Tuple, List
from concurrent.futures import ThreadPoolExecutor, TimeoutError

from flask import Flask, request, jsonify, make_response
from flask_cors import CORS

from helpers import (
    init_index,
    search_laws,
    build_html_answer,
    call_llm,
    web_enrich_official_sources,
    sanitize_html,  # <-- –¥–æ–±–∞–≤–∏–ª–∏
)

LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()
logging.basicConfig(level=LOG_LEVEL, format="%(asctime)s - %(levelname)s - %(message)s")
log = logging.getLogger(__name__)

app = Flask(__name__)

FRONTEND_ORIGIN = os.getenv("FRONTEND_ORIGIN", "")
if FRONTEND_ORIGIN:
    CORS(app, origins=[FRONTEND_ORIGIN], supports_credentials=True)
    log.info(f"‚úÖ CORS –≤–∫–ª—é—á—ë–Ω –¥–ª—è: {FRONTEND_ORIGIN}")
else:
    CORS(app, supports_credentials=True)
    log.warning("‚ö†Ô∏è  FRONTEND_ORIGIN –Ω–µ –∑–∞–¥–∞–Ω ‚Äî CORS –æ—Ç–∫—Ä—ã—Ç –¥–ª—è –≤—Å–µ—Ö (dev only).")

DOCS, INDEX = init_index()
log.info("‚úÖ –ò–Ω–¥–µ–∫—Å –≥–æ—Ç–æ–≤: %d —Ñ—Ä–∞–≥–º–µ–Ω—Ç–æ–≤", len(DOCS))

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã LLM
_executor = ThreadPoolExecutor(max_workers=4)
LLM_TIMEOUT_SEC = int(os.getenv("LLM_TIMEOUT_SEC", "28"))  # –∫–æ—Ä–æ—Ç–∫–∏–π —Ç–∞–π–º–∞—É—Ç –ø—Ä–æ—Ç–∏–≤ 504

def _preview_bytes(b: bytes, limit: int = 500) -> str:
    try:
        t = b.decode("utf-8", errors="replace")
    except Exception:
        return f"<{len(b)} bytes, decode failed>"
    t = t.strip().replace("\n", "\\n")
    return (t[:limit] + ("‚Ä¶" if len(t) > limit else "")) or "<empty>"

def get_json_payload() -> Tuple[Dict, Dict]:
    headers = {k.lower(): v for k, v in request.headers.items()}
    ctype = headers.get("content-type", "")
    raw = request.get_data()
    dbg = {"content_type": ctype, "body_preview": _preview_bytes(raw), "json_error": None}
    payload = {}
    if raw:
        try:
            payload = json.loads(raw.decode("utf-8", errors="replace"))
        except Exception as e:
            dbg["json_error"] = str(e)
    return payload, dbg

def json_error(status: int, code: str, message: str, debug: Dict = None):
    body = {"ok": False, "error": {"code": code, "message": message}}
    if debug:
        body["debug"] = debug
    resp = make_response(jsonify(body), status)
    resp.headers["Content-Type"] = "application/json; charset=utf-8"
    return resp

@app.route("/health", methods=["GET"])
@app.route("/api/health", methods=["GET"])
def health():
    llm_ready = bool(os.getenv("GEMINI_API_KEY"))
    return jsonify({"ok": True, "laws_count": len(DOCS), "llm": llm_ready, "message": "alive"})

def _handle_ask():
    started = time.time()
    payload, dbg = get_json_payload()
    question = (payload.get("question") or "").strip()
    if not question:
        return json_error(400, "MISSING_FIELD", "–ü–æ–ª–µ 'question' –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –∏ –Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø—É—Å—Ç—ã–º.", dbg)

    log.info("üë§ –í–æ–ø—Ä–æ—Å: %s", question)

    hits, intent = search_laws(question, DOCS, INDEX, top_k=5)
    log.info("üîé –°–æ–≤–ø–∞–¥–µ–Ω–∏–π: %d | intent: %s", len(hits), intent)

    # –í–µ–±-–æ–±–æ–≥–∞—â–µ–Ω–∏–µ (–µ—Å–ª–∏ –∑–∞–¥–∞–Ω—ã –∫–ª—é—á–∏)
    web_sources: List[Dict] = []
    try:
        web_sources = web_enrich_official_sources(question, limit=3)
        if web_sources:
            log.info("üåê –í–µ–±-–∏—Å—Ç–æ—á–Ω–∏–∫–∏: %d", len(web_sources))
    except Exception as e:
        log.warning("web_enrich_official_sources failed: %s", e)

    # LLM —Å —Ç–∞–π–º–∞—É—Ç–æ–º
    llm_html = ""
    try:
        fut = _executor.submit(call_llm, question, hits, intent, web_sources)
        llm_html = fut.result(timeout=LLM_TIMEOUT_SEC) or ""
    except TimeoutError:
        log.error("‚è≥ LLM timeout (%ss) ‚Äî –æ—Ç–¥–∞—ë–º rule-based fallback", LLM_TIMEOUT_SEC)
    except Exception as e:
        log.exception("LLM fail: %s", e)

    # –§–∏–Ω–∞–ª—å–Ω–∞—è —Å–±–æ—Ä–∫–∞ + —Å–∞–Ω–∏—Ç–∞–π–∑–µ—Ä
    answer_html = (llm_html.strip() or build_html_answer(question, hits, intent, web_sources)).strip()
    answer_html = sanitize_html(answer_html)  # <-- –≥–ª–∞–≤–Ω–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
    took = int((time.time() - started) * 1000)
    log.info("‚úÖ –û—Ç–≤–µ—Ç –≥–æ—Ç–æ–≤ (%d —Å–∏–º–≤) –∑–∞ %d –º—Å", len(answer_html), took)

    return jsonify({
        "ok": True,
        "answer_html": answer_html,
        "matches": [
            {
                "article_title": r.get("article_title"),
                "law_title": r.get("law_title"),
                "source": r.get("source"),
                "score": s
            }
            for r, s in hits
        ],
        "intent": intent,
        "took_ms": took
    })

@app.route("/ask", methods=["POST", "OPTIONS"])
@app.route("/api/ask", methods=["POST", "OPTIONS"])
def ask():
    if request.method == "OPTIONS":
        return ("", 204)
    try:
        return _handle_ask()
    except Exception as e:
        log.exception("üî• INTERNAL_ERROR in /ask: %s", e)
        return json_error(500, "INTERNAL_ERROR", str(e))

@app.route("/", methods=["GET"])
def root_404():
    return make_response("Not Found", 404)

if __name__ == "__main__":
    port = int(os.getenv("PORT", "5000"))
    app.run(host="0.0.0.0", port=port)
